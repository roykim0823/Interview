reverse string or any array

template<typename T>
void swap(T& a, T& b) {
    T x = a;
    a = b;
    b = a;
}

template<typename T>
void reverse(T *a, size_t n) {
    for(int i=0; i<2/n; i++) {	// if n is an odd number,  the middle one is not touched
	swap(a[i], a[n-i-1]);
}

================================================================================
Square root fo an integer
- Given Given an integer x, find square root of it. If x is not a perfect square, then return floor(¡îx).

A Simple Solution to find floor of square root is to try all numbers starting from 1. For every tried number i, if i*i is smaller than x, then increment i. We stop when i*i becomes more than or equal to x. Below is the implementation of above idea.

// A C++ program to find floor(sqrt(x)
#include<bits/stdc++.h>
using namespace std;
 
// Returns floor of square root of x
int floorSqrt(int x)
{
    // Base cases
    if (x == 0 || x == 1)
    return x;
 
    // Staring from 1, try all numbers until
    // i*i is greater than or equal to x.
    int i = 1, result = 1;
    while (result <= x)
    {
      i++;
      result = i * i;
    }
    return i - 1;
}
 
-> O(sqrt(x))

A Better Solution to do Binary Search.
Let  's' be the answer.  We know that 0 <=  s <= x.

Consider any random number r. 

    If r*r <= x, s >= r

    If r*r > x, s < r. 

Algorithm:
1) Start with 'start' = 0, end = 'x',
2) Do following while 'start' is smaller than or equal to 'end'.
      a) Compute 'mid' as (start + end)/2
      b) compare mid*mid with x.
      c) If x is equal to mid*mid, return mid.
      d) If x is greater, do binary search between mid+1 and end. In this case, we also update ans (Note that we need floor).
      e) If x is smaller, do binary search between start and mid-1

Below is the implementation of above idea.

// A C++ program to find floor(sqrt(x)
#include<bits/stdc++.h>
using namespace std;
 
// Returns floor of square root of x         
int floorSqrt(int x) 
{    
    // Base cases
    if (x == 0 || x == 1) 
       return x;
 
    // Do Binary Search for floor(sqrt(x))
    int start = 1, end = x, ans;   
    while (start <= end) 
    {        
        int mid = (start + end) / 2;
 
        // If x is a perfect square
        if (mid*mid == x)
            return mid;
 
        // Since we need floor, we update answer when mid*mid is 
        // smaller than x, and move closer to sqrt(x)
        if (mid*mid < x) 
        {
            start = mid + 1;
            ans = mid;
        } 
        else // If mid*mid is greater than x
            end = mid - 1;        
    }
    return ans;
}

-> O(logx)
Double version: EPI-8.9 (p.263)
implement sqrt(x)

void main() 
{ 
float a,b,c; 
printf("\n enther the number square root who wanna found\n"); 
scanf("%f",&a); 
int i,j; 
b=a; 
for(i=1;i<10;i++) 
{ 
b=0.5*(b+a/b); 
} 
printf("\nsqrt of %f is %f\n\n",i,a,b); 
}
-----------
=======================================================================
Find a duplicate number in a given array. The numbers are  1 ... n
void printRepeating(int arr[], int size)
{
  int i;
  printf("The repeating elements are: \n");
  for (i = 0; i < size; i++)
  {
    if (arr[abs(arr[i])] >= 0) // accessed changed the sign
      arr[abs(arr[i])] = -arr[abs(arr[i])];
    else // if it is already changed the sign
      printf(" %d ", abs(arr[i]));
  }
}
============================================================
implement strlen function
unsigned short strlen4(char *str)
{
    for (int i = 0; ; i++) if (str[i] == '\0') return i;
}
===========================================
find n-th element from end of a singly linked list 
- solution, used circular buffer.
====================================

Write implementation of strcpy method.  
//str copy function self made
char *strcpynew(char *d, char *s){
   char *saved = d;
   while ((*d++ = *s++) != '\0');

   return saved; //returning starting address of s1
}

===============================
If there're n points, how many distinct lines can you draw
n choose 2
 
====================================
Big Endian and Little Endian

unsigned int i = 0x12345678 (@0x10)

- Big Endian (Spark, ARM)
	12 34 56 78
@0x	10 11 12 13

- Little Endian (x86)
	78 56 34 12
@0x	10 11 12 13

Q. Write a piece of code to find out if the system is x86 or Sparc
-> Use Endian

A.
bool endian() {
	int num=1;
	char *ptr = (char&)&num;
	return (*ptr);	// return the byte of the lower adderss
}

1 if x86, 0 if Sparc
====================================================================================
A producer continuously produces a stream of characters. There are multiple consumer threads which read the chars and match to one of known strings and increment the counter for that pattern. Write the consumer function. Show how you will synchronize and maintain parallelism. 

Ex: Producer: abcdegabccaabbaacv ...... 
Known strings[] = {"ab", "aa", "fff" ... } 
patternMatchCount[] = {3, 2, 0 ... }

A.
strings = { "ab" : 0 , "aa" : 1 , "fff" : 2 , ... }
counters = [ 3, 2, 0, ...]

def increment_counter( s ){
   idx = strings[ s ]
   #atomic{
      // make atomic operation : increment 
      counters[idx] += 1
   }
}
===============================================================================	
Write a function in C to create a new BST which is the mirror image of a given tree.

A.
node* mirrorBST(node *bst1 , node *bst2) 
{ 
	if(bst1 != NULL) 
	{ 
		bst2 = (node*)malloc(sizeof(node)); 
		bst2->val = bst1->val; 
		bst2->left = NULL; 
		bst2->right = NULL; 
		//printf("v = %d\n",root2->val ); 
		
		bst2->right = mirrorBST(bst1->left,bst2->right); 
		bst2->left = mirrorBST(bst1->right,bst2->left); 
		return bst2; 
	} else 	{ 
		return NULL; 
	} 
}
------------------------------------------------------------------------------------
Q. Consider the statement 
result = a ? b : c; 
Implement the above statement without using any conditional statements.


!a -> 0 if a!=0
!a -> 1 if a==0

!!a -> 1 if a!=0, 
!!a -> 0 if a==0

if a b c and result are int

int temp[]= { b, c}
result = temp[!a];
========================================================
Write a multi threaded C code with one thread printing all even numbers and the other all odd numbers. The output should always be in sequence 
ie. 0,1,2,3,4....etc

A.
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdbool.h>

bool printOddNum;
int amountOfNums = 30;
pthread_mutex_t theMutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cv;

void* printEven(void* vargp)
{
	for (int i = 1; i < amountOfNums / 2; i++)
	{
		pthread_mutex_lock(&theMutex);
		
		while (printOddNum)
		{
			pthread_cond_wait(&cv, &theMutex);
		}

		printf("%d\n", 2 * i);

		printOddNum = true;

		pthread_cond_signal(&cv);
		pthread_mutex_unlock(&theMutex);
	}
	
	return NULL;
}

void* printOdd(void* vargp)
{
	for(int i = 1; i < amountOfNums / 2; i++)
	{
		pthread_mutex_lock(&theMutex);

		while (!printOddNum)
		{
			pthread_cond_wait(&cv, &theMutex);
		}

		printf("%d\n", 2 * i - 1);

		printOddNum = false;

		pthread_cond_signal(&cv);
		pthread_mutex_unlock(&theMutex);
	}
	
	return NULL;
}

int main()
{
	pthread_t evenThreadID;
	pthread_t oddThreadID;
	printOddNum = true;

	pthread_mutex_init(&theMutex, NULL);
	pthread_cond_init(&cv, NULL);

	pthread_create(&oddThreadID, NULL, printOdd, NULL);
	pthread_create(&evenThreadID, NULL, printEven, NULL);
	
	pthread_join(evenThreadID, NULL);
	pthread_join(oddThreadID, NULL);

	pthread_mutex_destroy(&theMutex);
	pthread_cond_destroy(&cv);

	system("pause");
	return 0;
}
==========================================
How will you implement run-time polymorphism in C? There are two structs. There is a common function receiving only one argument(only one). The function should accept both base struct and derived struct objects and do corresponding actions. i.e if base struct object is passed, do base struct's task and vice versa

#include<stdlib.h>
#include<stdio.h>

void task1(){
    printf("I am base class object\n");
}

void task2(){
    printf("I am derived class object\n");
}


typedef void (*fnptr_t)(void );

static fnptr_t vatable_A[1]={task1};
static fnptr_t vatable_B[1]={task2};

struct A{
    fnptr_t *vptr;
    int _a;
};

struct B{
    fnptr_t * vptr;
    int _b;
};

void init_A(struct A* p ){
    p->vptr= vatable_A;
    p->_a=0;
}

void init_B(struct B* p){
    p->vptr= vatable_B;
    p->_b=0;
}

void func(void* ob){
    /*And this something dark magic.*/
    struct A* p = (struct A*)ob;
    p->vptr[0]();

}

int main(){
    struct A ob_a;
    struct B ob_b;
    init_A(&ob_a);
    func((void*)&ob_a);

    init_B(&ob_b);
    func((void*)&ob_b);
    return 0;
}

======================

angle between hands of the clock.. the interviewer was expecting me to have a formula memorized. i told him i dont know any formula so i derived an equation which worked. he was still very skeptical abt it, until i did some testing n showed him it works.

abs(h*(360/12)+(m/60)*(360/12) - m*6)
